# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from kuka_robot/kr_robot_state_Type.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import kuka_robot.msg

class kr_robot_state_Type(genpy.Message):
  _md5sum = "52f44fa93866f06da1a2394c1fd725bd"
  _type = "kuka_robot/kr_robot_state_Type"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# Timestamp [s]
float64 timestamp

# Pose setpoint [mm, c]
kuka_robot/kr_pose_Type pos_setpt

# Joints setpoint [c]
kuka_robot/kr_joint_Type axis_setpt

# Pose feedback [mm, c]
kuka_robot/kr_pose_Type pos_fb

# Joints feedback [c]
kuka_robot/kr_joint_Type axis_fb

# Distance next [mm]
float64 dist_next

# Velocity act [mm]
float64 vel_act

# Axis velocity act [c/s, 0-A1...5-A6]
float64[6] vel_axis_act

# Axis current act [%, 0-A1...5-A6]
float64[6] curr_act

# Axis motor temperature [c, 0-A1...5-A6]
float64[6] mot_temp

# Motor brake [bitwise, 0-braked 1-released]
int64 brake_sig

# Command action number [0-idle, xx-moving]
int64 com_action

# Command motion stop state [0-resume, 1-paused, 2-canceling]
int64 com_motstop

# Command motion (last one) elapsed time [mm]
int64 com_last_mot_time

# Command signal input port state [bitwise]
int64 com_di_port_value

# Command signal output port state [bitwise]
int64 com_do_port_value


# Slow update. Command error number [0~xxxx]
int64 com_error_no

# Slow update. Command alarm state normal [true/false]
bool com_alarm_normal

# Slow update. Command signal move enable (to stop auto external mode) [true/false]
bool com_move_enable

# Slow update. Command signal auto external mode start [true/false]
bool com_autext_start

# Slow update. Operation mode status [#T1/#T2/#AUT/#EX]
string mode_op

# Slow update. Overrided speed scale [%, 0~100]
int64 ov_pro

# Slow update. Power failure status [true/false]
bool power_fail

# Slow update. Safety switch status [#PRESSED/#RELEASED]
string safety_sw

# Slow update. Error status
kuka_robot/kr_robot_error_Type err



================================================================================
MSG: kuka_robot/kr_pose_Type
# XYZ coordinate [mm]
float64 X
float64 Y
float64 Z
# ABC orientation [mm]
float64 A
float64 B
float64 C
# Status and Turn [unit]
float64 S
float64 T

================================================================================
MSG: kuka_robot/kr_joint_Type
# Joint Angles [degree]
float64 A1
float64 A2
float64 A3
float64 A4
float64 A5
float64 A6


================================================================================
MSG: kuka_robot/kr_robot_error_Type
# Error number
int64 number

# R_INT
string interpreter

# I_NORMAL
string int_type

# Prio
int64 int_prio

# Line number
int64 line_nr

# Module name
string module

# Up name
string up_name

# TRG_NONE
string trigger_type

"""
  __slots__ = ['timestamp','pos_setpt','axis_setpt','pos_fb','axis_fb','dist_next','vel_act','vel_axis_act','curr_act','mot_temp','brake_sig','com_action','com_motstop','com_last_mot_time','com_di_port_value','com_do_port_value','com_error_no','com_alarm_normal','com_move_enable','com_autext_start','mode_op','ov_pro','power_fail','safety_sw','err']
  _slot_types = ['float64','kuka_robot/kr_pose_Type','kuka_robot/kr_joint_Type','kuka_robot/kr_pose_Type','kuka_robot/kr_joint_Type','float64','float64','float64[6]','float64[6]','float64[6]','int64','int64','int64','int64','int64','int64','int64','bool','bool','bool','string','int64','bool','string','kuka_robot/kr_robot_error_Type']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       timestamp,pos_setpt,axis_setpt,pos_fb,axis_fb,dist_next,vel_act,vel_axis_act,curr_act,mot_temp,brake_sig,com_action,com_motstop,com_last_mot_time,com_di_port_value,com_do_port_value,com_error_no,com_alarm_normal,com_move_enable,com_autext_start,mode_op,ov_pro,power_fail,safety_sw,err

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(kr_robot_state_Type, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.timestamp is None:
        self.timestamp = 0.
      if self.pos_setpt is None:
        self.pos_setpt = kuka_robot.msg.kr_pose_Type()
      if self.axis_setpt is None:
        self.axis_setpt = kuka_robot.msg.kr_joint_Type()
      if self.pos_fb is None:
        self.pos_fb = kuka_robot.msg.kr_pose_Type()
      if self.axis_fb is None:
        self.axis_fb = kuka_robot.msg.kr_joint_Type()
      if self.dist_next is None:
        self.dist_next = 0.
      if self.vel_act is None:
        self.vel_act = 0.
      if self.vel_axis_act is None:
        self.vel_axis_act = [0.] * 6
      if self.curr_act is None:
        self.curr_act = [0.] * 6
      if self.mot_temp is None:
        self.mot_temp = [0.] * 6
      if self.brake_sig is None:
        self.brake_sig = 0
      if self.com_action is None:
        self.com_action = 0
      if self.com_motstop is None:
        self.com_motstop = 0
      if self.com_last_mot_time is None:
        self.com_last_mot_time = 0
      if self.com_di_port_value is None:
        self.com_di_port_value = 0
      if self.com_do_port_value is None:
        self.com_do_port_value = 0
      if self.com_error_no is None:
        self.com_error_no = 0
      if self.com_alarm_normal is None:
        self.com_alarm_normal = False
      if self.com_move_enable is None:
        self.com_move_enable = False
      if self.com_autext_start is None:
        self.com_autext_start = False
      if self.mode_op is None:
        self.mode_op = ''
      if self.ov_pro is None:
        self.ov_pro = 0
      if self.power_fail is None:
        self.power_fail = False
      if self.safety_sw is None:
        self.safety_sw = ''
      if self.err is None:
        self.err = kuka_robot.msg.kr_robot_error_Type()
    else:
      self.timestamp = 0.
      self.pos_setpt = kuka_robot.msg.kr_pose_Type()
      self.axis_setpt = kuka_robot.msg.kr_joint_Type()
      self.pos_fb = kuka_robot.msg.kr_pose_Type()
      self.axis_fb = kuka_robot.msg.kr_joint_Type()
      self.dist_next = 0.
      self.vel_act = 0.
      self.vel_axis_act = [0.] * 6
      self.curr_act = [0.] * 6
      self.mot_temp = [0.] * 6
      self.brake_sig = 0
      self.com_action = 0
      self.com_motstop = 0
      self.com_last_mot_time = 0
      self.com_di_port_value = 0
      self.com_do_port_value = 0
      self.com_error_no = 0
      self.com_alarm_normal = False
      self.com_move_enable = False
      self.com_autext_start = False
      self.mode_op = ''
      self.ov_pro = 0
      self.power_fail = False
      self.safety_sw = ''
      self.err = kuka_robot.msg.kr_robot_error_Type()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_31d().pack(_x.timestamp, _x.pos_setpt.X, _x.pos_setpt.Y, _x.pos_setpt.Z, _x.pos_setpt.A, _x.pos_setpt.B, _x.pos_setpt.C, _x.pos_setpt.S, _x.pos_setpt.T, _x.axis_setpt.A1, _x.axis_setpt.A2, _x.axis_setpt.A3, _x.axis_setpt.A4, _x.axis_setpt.A5, _x.axis_setpt.A6, _x.pos_fb.X, _x.pos_fb.Y, _x.pos_fb.Z, _x.pos_fb.A, _x.pos_fb.B, _x.pos_fb.C, _x.pos_fb.S, _x.pos_fb.T, _x.axis_fb.A1, _x.axis_fb.A2, _x.axis_fb.A3, _x.axis_fb.A4, _x.axis_fb.A5, _x.axis_fb.A6, _x.dist_next, _x.vel_act))
      buff.write(_get_struct_6d().pack(*self.vel_axis_act))
      buff.write(_get_struct_6d().pack(*self.curr_act))
      buff.write(_get_struct_6d().pack(*self.mot_temp))
      _x = self
      buff.write(_get_struct_7q3B().pack(_x.brake_sig, _x.com_action, _x.com_motstop, _x.com_last_mot_time, _x.com_di_port_value, _x.com_do_port_value, _x.com_error_no, _x.com_alarm_normal, _x.com_move_enable, _x.com_autext_start))
      _x = self.mode_op
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_qB().pack(_x.ov_pro, _x.power_fail))
      _x = self.safety_sw
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_get_struct_q().pack(self.err.number))
      _x = self.err.interpreter
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.int_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2q().pack(_x.err.int_prio, _x.err.line_nr))
      _x = self.err.module
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.up_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.trigger_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.pos_setpt is None:
        self.pos_setpt = kuka_robot.msg.kr_pose_Type()
      if self.axis_setpt is None:
        self.axis_setpt = kuka_robot.msg.kr_joint_Type()
      if self.pos_fb is None:
        self.pos_fb = kuka_robot.msg.kr_pose_Type()
      if self.axis_fb is None:
        self.axis_fb = kuka_robot.msg.kr_joint_Type()
      if self.err is None:
        self.err = kuka_robot.msg.kr_robot_error_Type()
      end = 0
      _x = self
      start = end
      end += 248
      (_x.timestamp, _x.pos_setpt.X, _x.pos_setpt.Y, _x.pos_setpt.Z, _x.pos_setpt.A, _x.pos_setpt.B, _x.pos_setpt.C, _x.pos_setpt.S, _x.pos_setpt.T, _x.axis_setpt.A1, _x.axis_setpt.A2, _x.axis_setpt.A3, _x.axis_setpt.A4, _x.axis_setpt.A5, _x.axis_setpt.A6, _x.pos_fb.X, _x.pos_fb.Y, _x.pos_fb.Z, _x.pos_fb.A, _x.pos_fb.B, _x.pos_fb.C, _x.pos_fb.S, _x.pos_fb.T, _x.axis_fb.A1, _x.axis_fb.A2, _x.axis_fb.A3, _x.axis_fb.A4, _x.axis_fb.A5, _x.axis_fb.A6, _x.dist_next, _x.vel_act,) = _get_struct_31d().unpack(str[start:end])
      start = end
      end += 48
      self.vel_axis_act = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.curr_act = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 48
      self.mot_temp = _get_struct_6d().unpack(str[start:end])
      _x = self
      start = end
      end += 59
      (_x.brake_sig, _x.com_action, _x.com_motstop, _x.com_last_mot_time, _x.com_di_port_value, _x.com_do_port_value, _x.com_error_no, _x.com_alarm_normal, _x.com_move_enable, _x.com_autext_start,) = _get_struct_7q3B().unpack(str[start:end])
      self.com_alarm_normal = bool(self.com_alarm_normal)
      self.com_move_enable = bool(self.com_move_enable)
      self.com_autext_start = bool(self.com_autext_start)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_op = str[start:end].decode('utf-8')
      else:
        self.mode_op = str[start:end]
      _x = self
      start = end
      end += 9
      (_x.ov_pro, _x.power_fail,) = _get_struct_qB().unpack(str[start:end])
      self.power_fail = bool(self.power_fail)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.safety_sw = str[start:end].decode('utf-8')
      else:
        self.safety_sw = str[start:end]
      start = end
      end += 8
      (self.err.number,) = _get_struct_q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.interpreter = str[start:end].decode('utf-8')
      else:
        self.err.interpreter = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.int_type = str[start:end].decode('utf-8')
      else:
        self.err.int_type = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.err.int_prio, _x.err.line_nr,) = _get_struct_2q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.module = str[start:end].decode('utf-8')
      else:
        self.err.module = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.up_name = str[start:end].decode('utf-8')
      else:
        self.err.up_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.trigger_type = str[start:end].decode('utf-8')
      else:
        self.err.trigger_type = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_31d().pack(_x.timestamp, _x.pos_setpt.X, _x.pos_setpt.Y, _x.pos_setpt.Z, _x.pos_setpt.A, _x.pos_setpt.B, _x.pos_setpt.C, _x.pos_setpt.S, _x.pos_setpt.T, _x.axis_setpt.A1, _x.axis_setpt.A2, _x.axis_setpt.A3, _x.axis_setpt.A4, _x.axis_setpt.A5, _x.axis_setpt.A6, _x.pos_fb.X, _x.pos_fb.Y, _x.pos_fb.Z, _x.pos_fb.A, _x.pos_fb.B, _x.pos_fb.C, _x.pos_fb.S, _x.pos_fb.T, _x.axis_fb.A1, _x.axis_fb.A2, _x.axis_fb.A3, _x.axis_fb.A4, _x.axis_fb.A5, _x.axis_fb.A6, _x.dist_next, _x.vel_act))
      buff.write(self.vel_axis_act.tostring())
      buff.write(self.curr_act.tostring())
      buff.write(self.mot_temp.tostring())
      _x = self
      buff.write(_get_struct_7q3B().pack(_x.brake_sig, _x.com_action, _x.com_motstop, _x.com_last_mot_time, _x.com_di_port_value, _x.com_do_port_value, _x.com_error_no, _x.com_alarm_normal, _x.com_move_enable, _x.com_autext_start))
      _x = self.mode_op
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_qB().pack(_x.ov_pro, _x.power_fail))
      _x = self.safety_sw
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_get_struct_q().pack(self.err.number))
      _x = self.err.interpreter
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.int_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2q().pack(_x.err.int_prio, _x.err.line_nr))
      _x = self.err.module
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.up_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.err.trigger_type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.pos_setpt is None:
        self.pos_setpt = kuka_robot.msg.kr_pose_Type()
      if self.axis_setpt is None:
        self.axis_setpt = kuka_robot.msg.kr_joint_Type()
      if self.pos_fb is None:
        self.pos_fb = kuka_robot.msg.kr_pose_Type()
      if self.axis_fb is None:
        self.axis_fb = kuka_robot.msg.kr_joint_Type()
      if self.err is None:
        self.err = kuka_robot.msg.kr_robot_error_Type()
      end = 0
      _x = self
      start = end
      end += 248
      (_x.timestamp, _x.pos_setpt.X, _x.pos_setpt.Y, _x.pos_setpt.Z, _x.pos_setpt.A, _x.pos_setpt.B, _x.pos_setpt.C, _x.pos_setpt.S, _x.pos_setpt.T, _x.axis_setpt.A1, _x.axis_setpt.A2, _x.axis_setpt.A3, _x.axis_setpt.A4, _x.axis_setpt.A5, _x.axis_setpt.A6, _x.pos_fb.X, _x.pos_fb.Y, _x.pos_fb.Z, _x.pos_fb.A, _x.pos_fb.B, _x.pos_fb.C, _x.pos_fb.S, _x.pos_fb.T, _x.axis_fb.A1, _x.axis_fb.A2, _x.axis_fb.A3, _x.axis_fb.A4, _x.axis_fb.A5, _x.axis_fb.A6, _x.dist_next, _x.vel_act,) = _get_struct_31d().unpack(str[start:end])
      start = end
      end += 48
      self.vel_axis_act = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.curr_act = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      start = end
      end += 48
      self.mot_temp = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=6)
      _x = self
      start = end
      end += 59
      (_x.brake_sig, _x.com_action, _x.com_motstop, _x.com_last_mot_time, _x.com_di_port_value, _x.com_do_port_value, _x.com_error_no, _x.com_alarm_normal, _x.com_move_enable, _x.com_autext_start,) = _get_struct_7q3B().unpack(str[start:end])
      self.com_alarm_normal = bool(self.com_alarm_normal)
      self.com_move_enable = bool(self.com_move_enable)
      self.com_autext_start = bool(self.com_autext_start)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.mode_op = str[start:end].decode('utf-8')
      else:
        self.mode_op = str[start:end]
      _x = self
      start = end
      end += 9
      (_x.ov_pro, _x.power_fail,) = _get_struct_qB().unpack(str[start:end])
      self.power_fail = bool(self.power_fail)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.safety_sw = str[start:end].decode('utf-8')
      else:
        self.safety_sw = str[start:end]
      start = end
      end += 8
      (self.err.number,) = _get_struct_q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.interpreter = str[start:end].decode('utf-8')
      else:
        self.err.interpreter = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.int_type = str[start:end].decode('utf-8')
      else:
        self.err.int_type = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.err.int_prio, _x.err.line_nr,) = _get_struct_2q().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.module = str[start:end].decode('utf-8')
      else:
        self.err.module = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.up_name = str[start:end].decode('utf-8')
      else:
        self.err.up_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.err.trigger_type = str[start:end].decode('utf-8')
      else:
        self.err.trigger_type = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_2q = None
def _get_struct_2q():
    global _struct_2q
    if _struct_2q is None:
        _struct_2q = struct.Struct("<2q")
    return _struct_2q
_struct_7q3B = None
def _get_struct_7q3B():
    global _struct_7q3B
    if _struct_7q3B is None:
        _struct_7q3B = struct.Struct("<7q3B")
    return _struct_7q3B
_struct_q = None
def _get_struct_q():
    global _struct_q
    if _struct_q is None:
        _struct_q = struct.Struct("<q")
    return _struct_q
_struct_qB = None
def _get_struct_qB():
    global _struct_qB
    if _struct_qB is None:
        _struct_qB = struct.Struct("<qB")
    return _struct_qB
_struct_31d = None
def _get_struct_31d():
    global _struct_31d
    if _struct_31d is None:
        _struct_31d = struct.Struct("<31d")
    return _struct_31d
