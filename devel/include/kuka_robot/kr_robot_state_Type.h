// Generated by gencpp from file kuka_robot/kr_robot_state_Type.msg
// DO NOT EDIT!


#ifndef KUKA_ROBOT_MESSAGE_KR_ROBOT_STATE_TYPE_H
#define KUKA_ROBOT_MESSAGE_KR_ROBOT_STATE_TYPE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <kuka_robot/kr_pose_Type.h>
#include <kuka_robot/kr_joint_Type.h>
#include <kuka_robot/kr_pose_Type.h>
#include <kuka_robot/kr_joint_Type.h>
#include <kuka_robot/kr_robot_error_Type.h>

namespace kuka_robot
{
template <class ContainerAllocator>
struct kr_robot_state_Type_
{
  typedef kr_robot_state_Type_<ContainerAllocator> Type;

  kr_robot_state_Type_()
    : timestamp(0.0)
    , pos_setpt()
    , axis_setpt()
    , pos_fb()
    , axis_fb()
    , dist_next(0.0)
    , vel_act(0.0)
    , vel_axis_act()
    , curr_act()
    , mot_temp()
    , brake_sig(0)
    , com_action(0)
    , com_motstop(0)
    , com_last_mot_time(0)
    , com_di_port_value(0)
    , com_do_port_value(0)
    , com_error_no(0)
    , com_alarm_normal(false)
    , com_move_enable(false)
    , com_autext_start(false)
    , mode_op()
    , ov_pro(0)
    , power_fail(false)
    , safety_sw()
    , err()  {
      vel_axis_act.assign(0.0);

      curr_act.assign(0.0);

      mot_temp.assign(0.0);
  }
  kr_robot_state_Type_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , pos_setpt(_alloc)
    , axis_setpt(_alloc)
    , pos_fb(_alloc)
    , axis_fb(_alloc)
    , dist_next(0.0)
    , vel_act(0.0)
    , vel_axis_act()
    , curr_act()
    , mot_temp()
    , brake_sig(0)
    , com_action(0)
    , com_motstop(0)
    , com_last_mot_time(0)
    , com_di_port_value(0)
    , com_do_port_value(0)
    , com_error_no(0)
    , com_alarm_normal(false)
    , com_move_enable(false)
    , com_autext_start(false)
    , mode_op(_alloc)
    , ov_pro(0)
    , power_fail(false)
    , safety_sw(_alloc)
    , err(_alloc)  {
  (void)_alloc;
      vel_axis_act.assign(0.0);

      curr_act.assign(0.0);

      mot_temp.assign(0.0);
  }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef  ::kuka_robot::kr_pose_Type_<ContainerAllocator>  _pos_setpt_type;
  _pos_setpt_type pos_setpt;

   typedef  ::kuka_robot::kr_joint_Type_<ContainerAllocator>  _axis_setpt_type;
  _axis_setpt_type axis_setpt;

   typedef  ::kuka_robot::kr_pose_Type_<ContainerAllocator>  _pos_fb_type;
  _pos_fb_type pos_fb;

   typedef  ::kuka_robot::kr_joint_Type_<ContainerAllocator>  _axis_fb_type;
  _axis_fb_type axis_fb;

   typedef double _dist_next_type;
  _dist_next_type dist_next;

   typedef double _vel_act_type;
  _vel_act_type vel_act;

   typedef boost::array<double, 6>  _vel_axis_act_type;
  _vel_axis_act_type vel_axis_act;

   typedef boost::array<double, 6>  _curr_act_type;
  _curr_act_type curr_act;

   typedef boost::array<double, 6>  _mot_temp_type;
  _mot_temp_type mot_temp;

   typedef int64_t _brake_sig_type;
  _brake_sig_type brake_sig;

   typedef int64_t _com_action_type;
  _com_action_type com_action;

   typedef int64_t _com_motstop_type;
  _com_motstop_type com_motstop;

   typedef int64_t _com_last_mot_time_type;
  _com_last_mot_time_type com_last_mot_time;

   typedef int64_t _com_di_port_value_type;
  _com_di_port_value_type com_di_port_value;

   typedef int64_t _com_do_port_value_type;
  _com_do_port_value_type com_do_port_value;

   typedef int64_t _com_error_no_type;
  _com_error_no_type com_error_no;

   typedef uint8_t _com_alarm_normal_type;
  _com_alarm_normal_type com_alarm_normal;

   typedef uint8_t _com_move_enable_type;
  _com_move_enable_type com_move_enable;

   typedef uint8_t _com_autext_start_type;
  _com_autext_start_type com_autext_start;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _mode_op_type;
  _mode_op_type mode_op;

   typedef int64_t _ov_pro_type;
  _ov_pro_type ov_pro;

   typedef uint8_t _power_fail_type;
  _power_fail_type power_fail;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _safety_sw_type;
  _safety_sw_type safety_sw;

   typedef  ::kuka_robot::kr_robot_error_Type_<ContainerAllocator>  _err_type;
  _err_type err;





  typedef boost::shared_ptr< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> const> ConstPtr;

}; // struct kr_robot_state_Type_

typedef ::kuka_robot::kr_robot_state_Type_<std::allocator<void> > kr_robot_state_Type;

typedef boost::shared_ptr< ::kuka_robot::kr_robot_state_Type > kr_robot_state_TypePtr;
typedef boost::shared_ptr< ::kuka_robot::kr_robot_state_Type const> kr_robot_state_TypeConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator1> & lhs, const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.pos_setpt == rhs.pos_setpt &&
    lhs.axis_setpt == rhs.axis_setpt &&
    lhs.pos_fb == rhs.pos_fb &&
    lhs.axis_fb == rhs.axis_fb &&
    lhs.dist_next == rhs.dist_next &&
    lhs.vel_act == rhs.vel_act &&
    lhs.vel_axis_act == rhs.vel_axis_act &&
    lhs.curr_act == rhs.curr_act &&
    lhs.mot_temp == rhs.mot_temp &&
    lhs.brake_sig == rhs.brake_sig &&
    lhs.com_action == rhs.com_action &&
    lhs.com_motstop == rhs.com_motstop &&
    lhs.com_last_mot_time == rhs.com_last_mot_time &&
    lhs.com_di_port_value == rhs.com_di_port_value &&
    lhs.com_do_port_value == rhs.com_do_port_value &&
    lhs.com_error_no == rhs.com_error_no &&
    lhs.com_alarm_normal == rhs.com_alarm_normal &&
    lhs.com_move_enable == rhs.com_move_enable &&
    lhs.com_autext_start == rhs.com_autext_start &&
    lhs.mode_op == rhs.mode_op &&
    lhs.ov_pro == rhs.ov_pro &&
    lhs.power_fail == rhs.power_fail &&
    lhs.safety_sw == rhs.safety_sw &&
    lhs.err == rhs.err;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator1> & lhs, const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace kuka_robot

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "52f44fa93866f06da1a2394c1fd725bd";
  }

  static const char* value(const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x52f44fa93866f06dULL;
  static const uint64_t static_value2 = 0xa1a2394c1fd725bdULL;
};

template<class ContainerAllocator>
struct DataType< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "kuka_robot/kr_robot_state_Type";
  }

  static const char* value(const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Timestamp [s]\n"
"float64 timestamp\n"
"\n"
"# Pose setpoint [mm, c]\n"
"kuka_robot/kr_pose_Type pos_setpt\n"
"\n"
"# Joints setpoint [c]\n"
"kuka_robot/kr_joint_Type axis_setpt\n"
"\n"
"# Pose feedback [mm, c]\n"
"kuka_robot/kr_pose_Type pos_fb\n"
"\n"
"# Joints feedback [c]\n"
"kuka_robot/kr_joint_Type axis_fb\n"
"\n"
"# Distance next [mm]\n"
"float64 dist_next\n"
"\n"
"# Velocity act [mm]\n"
"float64 vel_act\n"
"\n"
"# Axis velocity act [c/s, 0-A1...5-A6]\n"
"float64[6] vel_axis_act\n"
"\n"
"# Axis current act [%, 0-A1...5-A6]\n"
"float64[6] curr_act\n"
"\n"
"# Axis motor temperature [c, 0-A1...5-A6]\n"
"float64[6] mot_temp\n"
"\n"
"# Motor brake [bitwise, 0-braked 1-released]\n"
"int64 brake_sig\n"
"\n"
"# Command action number [0-idle, xx-moving]\n"
"int64 com_action\n"
"\n"
"# Command motion stop state [0-resume, 1-paused, 2-canceling]\n"
"int64 com_motstop\n"
"\n"
"# Command motion (last one) elapsed time [mm]\n"
"int64 com_last_mot_time\n"
"\n"
"# Command signal input port state [bitwise]\n"
"int64 com_di_port_value\n"
"\n"
"# Command signal output port state [bitwise]\n"
"int64 com_do_port_value\n"
"\n"
"\n"
"# Slow update. Command error number [0~xxxx]\n"
"int64 com_error_no\n"
"\n"
"# Slow update. Command alarm state normal [true/false]\n"
"bool com_alarm_normal\n"
"\n"
"# Slow update. Command signal move enable (to stop auto external mode) [true/false]\n"
"bool com_move_enable\n"
"\n"
"# Slow update. Command signal auto external mode start [true/false]\n"
"bool com_autext_start\n"
"\n"
"# Slow update. Operation mode status [#T1/#T2/#AUT/#EX]\n"
"string mode_op\n"
"\n"
"# Slow update. Overrided speed scale [%, 0~100]\n"
"int64 ov_pro\n"
"\n"
"# Slow update. Power failure status [true/false]\n"
"bool power_fail\n"
"\n"
"# Slow update. Safety switch status [#PRESSED/#RELEASED]\n"
"string safety_sw\n"
"\n"
"# Slow update. Error status\n"
"kuka_robot/kr_robot_error_Type err\n"
"\n"
"\n"
"\n"
"================================================================================\n"
"MSG: kuka_robot/kr_pose_Type\n"
"# XYZ coordinate [mm]\n"
"float64 X\n"
"float64 Y\n"
"float64 Z\n"
"# ABC orientation [mm]\n"
"float64 A\n"
"float64 B\n"
"float64 C\n"
"# Status and Turn [unit]\n"
"float64 S\n"
"float64 T\n"
"\n"
"================================================================================\n"
"MSG: kuka_robot/kr_joint_Type\n"
"# Joint Angles [degree]\n"
"float64 A1\n"
"float64 A2\n"
"float64 A3\n"
"float64 A4\n"
"float64 A5\n"
"float64 A6\n"
"\n"
"\n"
"================================================================================\n"
"MSG: kuka_robot/kr_robot_error_Type\n"
"# Error number\n"
"int64 number\n"
"\n"
"# R_INT\n"
"string interpreter\n"
"\n"
"# I_NORMAL\n"
"string int_type\n"
"\n"
"# Prio\n"
"int64 int_prio\n"
"\n"
"# Line number\n"
"int64 line_nr\n"
"\n"
"# Module name\n"
"string module\n"
"\n"
"# Up name\n"
"string up_name\n"
"\n"
"# TRG_NONE\n"
"string trigger_type\n"
"\n"
;
  }

  static const char* value(const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.pos_setpt);
      stream.next(m.axis_setpt);
      stream.next(m.pos_fb);
      stream.next(m.axis_fb);
      stream.next(m.dist_next);
      stream.next(m.vel_act);
      stream.next(m.vel_axis_act);
      stream.next(m.curr_act);
      stream.next(m.mot_temp);
      stream.next(m.brake_sig);
      stream.next(m.com_action);
      stream.next(m.com_motstop);
      stream.next(m.com_last_mot_time);
      stream.next(m.com_di_port_value);
      stream.next(m.com_do_port_value);
      stream.next(m.com_error_no);
      stream.next(m.com_alarm_normal);
      stream.next(m.com_move_enable);
      stream.next(m.com_autext_start);
      stream.next(m.mode_op);
      stream.next(m.ov_pro);
      stream.next(m.power_fail);
      stream.next(m.safety_sw);
      stream.next(m.err);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct kr_robot_state_Type_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::kuka_robot::kr_robot_state_Type_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::kuka_robot::kr_robot_state_Type_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    s << indent << "pos_setpt: ";
    s << std::endl;
    Printer< ::kuka_robot::kr_pose_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.pos_setpt);
    s << indent << "axis_setpt: ";
    s << std::endl;
    Printer< ::kuka_robot::kr_joint_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.axis_setpt);
    s << indent << "pos_fb: ";
    s << std::endl;
    Printer< ::kuka_robot::kr_pose_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.pos_fb);
    s << indent << "axis_fb: ";
    s << std::endl;
    Printer< ::kuka_robot::kr_joint_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.axis_fb);
    s << indent << "dist_next: ";
    Printer<double>::stream(s, indent + "  ", v.dist_next);
    s << indent << "vel_act: ";
    Printer<double>::stream(s, indent + "  ", v.vel_act);
    s << indent << "vel_axis_act[]" << std::endl;
    for (size_t i = 0; i < v.vel_axis_act.size(); ++i)
    {
      s << indent << "  vel_axis_act[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.vel_axis_act[i]);
    }
    s << indent << "curr_act[]" << std::endl;
    for (size_t i = 0; i < v.curr_act.size(); ++i)
    {
      s << indent << "  curr_act[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.curr_act[i]);
    }
    s << indent << "mot_temp[]" << std::endl;
    for (size_t i = 0; i < v.mot_temp.size(); ++i)
    {
      s << indent << "  mot_temp[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.mot_temp[i]);
    }
    s << indent << "brake_sig: ";
    Printer<int64_t>::stream(s, indent + "  ", v.brake_sig);
    s << indent << "com_action: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_action);
    s << indent << "com_motstop: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_motstop);
    s << indent << "com_last_mot_time: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_last_mot_time);
    s << indent << "com_di_port_value: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_di_port_value);
    s << indent << "com_do_port_value: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_do_port_value);
    s << indent << "com_error_no: ";
    Printer<int64_t>::stream(s, indent + "  ", v.com_error_no);
    s << indent << "com_alarm_normal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.com_alarm_normal);
    s << indent << "com_move_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.com_move_enable);
    s << indent << "com_autext_start: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.com_autext_start);
    s << indent << "mode_op: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.mode_op);
    s << indent << "ov_pro: ";
    Printer<int64_t>::stream(s, indent + "  ", v.ov_pro);
    s << indent << "power_fail: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.power_fail);
    s << indent << "safety_sw: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.safety_sw);
    s << indent << "err: ";
    s << std::endl;
    Printer< ::kuka_robot::kr_robot_error_Type_<ContainerAllocator> >::stream(s, indent + "  ", v.err);
  }
};

} // namespace message_operations
} // namespace ros

#endif // KUKA_ROBOT_MESSAGE_KR_ROBOT_STATE_TYPE_H
