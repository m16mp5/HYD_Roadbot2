// Generated by gencpp from file roadbot_control/ac_state_Type.msg
// DO NOT EDIT!


#ifndef ROADBOT_CONTROL_MESSAGE_AC_STATE_TYPE_H
#define ROADBOT_CONTROL_MESSAGE_AC_STATE_TYPE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace roadbot_control
{
template <class ContainerAllocator>
struct ac_state_Type_
{
  typedef ac_state_Type_<ContainerAllocator> Type;

  ac_state_Type_()
    : timestamp(0.0)
    , reararm_sm(0)
    , frontarm_sm(0)
    , target_id(0)
    , target_pos_X(0.0)
    , target_pos_Y(0.0)
    , target_pos_Z(0.0)
    , target_vel_X(0.0)
    , target_vel_Y(0.0)
    , target_vel_Z(0.0)
    , target_acc_X(0.0)
    , target_acc_Y(0.0)
    , target_acc_Z(0.0)
    , roadmarkline_pos_X(0.0)
    , roadmarkline_pos_Y(0.0)
    , progress_place_count(0)
    , progress_place_in_total(0)
    , progress_collect_count(0)
    , progress_collect_in_total(0)
    , sb_slider_position(0)
    , sb_cones_in_total(0)
    , sb_cones_in_stack()
    , sb_current_stack(0)
    , sb_current_stacklevel(0)
    , lb_left_slot(0)
    , lb_right_slot(0)
    , lr_lanterns_in_total(0)
    , lr_lanterns_in_stack()
    , lr_current_stack(0)
    , lr_current_stacklevel(0)
    , rearDetectObjectInDeadZone(false)
    , rearDetectObjectInPlaceZoneRight(false)
    , rearDetectObjectInPlaceZoneCenter(false)
    , rearDetectObjectInPlaceZoneLeft(false)
    , rearDetectNonLockObjectInOperationZone(false)  {
    }
  ac_state_Type_(const ContainerAllocator& _alloc)
    : timestamp(0.0)
    , reararm_sm(0)
    , frontarm_sm(0)
    , target_id(0)
    , target_pos_X(0.0)
    , target_pos_Y(0.0)
    , target_pos_Z(0.0)
    , target_vel_X(0.0)
    , target_vel_Y(0.0)
    , target_vel_Z(0.0)
    , target_acc_X(0.0)
    , target_acc_Y(0.0)
    , target_acc_Z(0.0)
    , roadmarkline_pos_X(0.0)
    , roadmarkline_pos_Y(0.0)
    , progress_place_count(0)
    , progress_place_in_total(0)
    , progress_collect_count(0)
    , progress_collect_in_total(0)
    , sb_slider_position(0)
    , sb_cones_in_total(0)
    , sb_cones_in_stack(_alloc)
    , sb_current_stack(0)
    , sb_current_stacklevel(0)
    , lb_left_slot(0)
    , lb_right_slot(0)
    , lr_lanterns_in_total(0)
    , lr_lanterns_in_stack(_alloc)
    , lr_current_stack(0)
    , lr_current_stacklevel(0)
    , rearDetectObjectInDeadZone(false)
    , rearDetectObjectInPlaceZoneRight(false)
    , rearDetectObjectInPlaceZoneCenter(false)
    , rearDetectObjectInPlaceZoneLeft(false)
    , rearDetectNonLockObjectInOperationZone(false)  {
  (void)_alloc;
    }



   typedef double _timestamp_type;
  _timestamp_type timestamp;

   typedef int64_t _reararm_sm_type;
  _reararm_sm_type reararm_sm;

   typedef int64_t _frontarm_sm_type;
  _frontarm_sm_type frontarm_sm;

   typedef int64_t _target_id_type;
  _target_id_type target_id;

   typedef double _target_pos_X_type;
  _target_pos_X_type target_pos_X;

   typedef double _target_pos_Y_type;
  _target_pos_Y_type target_pos_Y;

   typedef double _target_pos_Z_type;
  _target_pos_Z_type target_pos_Z;

   typedef double _target_vel_X_type;
  _target_vel_X_type target_vel_X;

   typedef double _target_vel_Y_type;
  _target_vel_Y_type target_vel_Y;

   typedef double _target_vel_Z_type;
  _target_vel_Z_type target_vel_Z;

   typedef double _target_acc_X_type;
  _target_acc_X_type target_acc_X;

   typedef double _target_acc_Y_type;
  _target_acc_Y_type target_acc_Y;

   typedef double _target_acc_Z_type;
  _target_acc_Z_type target_acc_Z;

   typedef double _roadmarkline_pos_X_type;
  _roadmarkline_pos_X_type roadmarkline_pos_X;

   typedef double _roadmarkline_pos_Y_type;
  _roadmarkline_pos_Y_type roadmarkline_pos_Y;

   typedef int64_t _progress_place_count_type;
  _progress_place_count_type progress_place_count;

   typedef int64_t _progress_place_in_total_type;
  _progress_place_in_total_type progress_place_in_total;

   typedef int64_t _progress_collect_count_type;
  _progress_collect_count_type progress_collect_count;

   typedef int64_t _progress_collect_in_total_type;
  _progress_collect_in_total_type progress_collect_in_total;

   typedef int64_t _sb_slider_position_type;
  _sb_slider_position_type sb_slider_position;

   typedef int64_t _sb_cones_in_total_type;
  _sb_cones_in_total_type sb_cones_in_total;

   typedef std::vector<int64_t, typename ContainerAllocator::template rebind<int64_t>::other >  _sb_cones_in_stack_type;
  _sb_cones_in_stack_type sb_cones_in_stack;

   typedef int64_t _sb_current_stack_type;
  _sb_current_stack_type sb_current_stack;

   typedef int64_t _sb_current_stacklevel_type;
  _sb_current_stacklevel_type sb_current_stacklevel;

   typedef int64_t _lb_left_slot_type;
  _lb_left_slot_type lb_left_slot;

   typedef int64_t _lb_right_slot_type;
  _lb_right_slot_type lb_right_slot;

   typedef int64_t _lr_lanterns_in_total_type;
  _lr_lanterns_in_total_type lr_lanterns_in_total;

   typedef std::vector<int64_t, typename ContainerAllocator::template rebind<int64_t>::other >  _lr_lanterns_in_stack_type;
  _lr_lanterns_in_stack_type lr_lanterns_in_stack;

   typedef int64_t _lr_current_stack_type;
  _lr_current_stack_type lr_current_stack;

   typedef int64_t _lr_current_stacklevel_type;
  _lr_current_stacklevel_type lr_current_stacklevel;

   typedef uint8_t _rearDetectObjectInDeadZone_type;
  _rearDetectObjectInDeadZone_type rearDetectObjectInDeadZone;

   typedef uint8_t _rearDetectObjectInPlaceZoneRight_type;
  _rearDetectObjectInPlaceZoneRight_type rearDetectObjectInPlaceZoneRight;

   typedef uint8_t _rearDetectObjectInPlaceZoneCenter_type;
  _rearDetectObjectInPlaceZoneCenter_type rearDetectObjectInPlaceZoneCenter;

   typedef uint8_t _rearDetectObjectInPlaceZoneLeft_type;
  _rearDetectObjectInPlaceZoneLeft_type rearDetectObjectInPlaceZoneLeft;

   typedef uint8_t _rearDetectNonLockObjectInOperationZone_type;
  _rearDetectNonLockObjectInOperationZone_type rearDetectNonLockObjectInOperationZone;





  typedef boost::shared_ptr< ::roadbot_control::ac_state_Type_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::roadbot_control::ac_state_Type_<ContainerAllocator> const> ConstPtr;

}; // struct ac_state_Type_

typedef ::roadbot_control::ac_state_Type_<std::allocator<void> > ac_state_Type;

typedef boost::shared_ptr< ::roadbot_control::ac_state_Type > ac_state_TypePtr;
typedef boost::shared_ptr< ::roadbot_control::ac_state_Type const> ac_state_TypeConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::roadbot_control::ac_state_Type_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::roadbot_control::ac_state_Type_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::roadbot_control::ac_state_Type_<ContainerAllocator1> & lhs, const ::roadbot_control::ac_state_Type_<ContainerAllocator2> & rhs)
{
  return lhs.timestamp == rhs.timestamp &&
    lhs.reararm_sm == rhs.reararm_sm &&
    lhs.frontarm_sm == rhs.frontarm_sm &&
    lhs.target_id == rhs.target_id &&
    lhs.target_pos_X == rhs.target_pos_X &&
    lhs.target_pos_Y == rhs.target_pos_Y &&
    lhs.target_pos_Z == rhs.target_pos_Z &&
    lhs.target_vel_X == rhs.target_vel_X &&
    lhs.target_vel_Y == rhs.target_vel_Y &&
    lhs.target_vel_Z == rhs.target_vel_Z &&
    lhs.target_acc_X == rhs.target_acc_X &&
    lhs.target_acc_Y == rhs.target_acc_Y &&
    lhs.target_acc_Z == rhs.target_acc_Z &&
    lhs.roadmarkline_pos_X == rhs.roadmarkline_pos_X &&
    lhs.roadmarkline_pos_Y == rhs.roadmarkline_pos_Y &&
    lhs.progress_place_count == rhs.progress_place_count &&
    lhs.progress_place_in_total == rhs.progress_place_in_total &&
    lhs.progress_collect_count == rhs.progress_collect_count &&
    lhs.progress_collect_in_total == rhs.progress_collect_in_total &&
    lhs.sb_slider_position == rhs.sb_slider_position &&
    lhs.sb_cones_in_total == rhs.sb_cones_in_total &&
    lhs.sb_cones_in_stack == rhs.sb_cones_in_stack &&
    lhs.sb_current_stack == rhs.sb_current_stack &&
    lhs.sb_current_stacklevel == rhs.sb_current_stacklevel &&
    lhs.lb_left_slot == rhs.lb_left_slot &&
    lhs.lb_right_slot == rhs.lb_right_slot &&
    lhs.lr_lanterns_in_total == rhs.lr_lanterns_in_total &&
    lhs.lr_lanterns_in_stack == rhs.lr_lanterns_in_stack &&
    lhs.lr_current_stack == rhs.lr_current_stack &&
    lhs.lr_current_stacklevel == rhs.lr_current_stacklevel &&
    lhs.rearDetectObjectInDeadZone == rhs.rearDetectObjectInDeadZone &&
    lhs.rearDetectObjectInPlaceZoneRight == rhs.rearDetectObjectInPlaceZoneRight &&
    lhs.rearDetectObjectInPlaceZoneCenter == rhs.rearDetectObjectInPlaceZoneCenter &&
    lhs.rearDetectObjectInPlaceZoneLeft == rhs.rearDetectObjectInPlaceZoneLeft &&
    lhs.rearDetectNonLockObjectInOperationZone == rhs.rearDetectNonLockObjectInOperationZone;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::roadbot_control::ac_state_Type_<ContainerAllocator1> & lhs, const ::roadbot_control::ac_state_Type_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace roadbot_control

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::roadbot_control::ac_state_Type_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::roadbot_control::ac_state_Type_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::roadbot_control::ac_state_Type_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ab807b4f227aecbfa526561d1e53b40a";
  }

  static const char* value(const ::roadbot_control::ac_state_Type_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xab807b4f227aecbfULL;
  static const uint64_t static_value2 = 0xa526561d1e53b40aULL;
};

template<class ContainerAllocator>
struct DataType< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "roadbot_control/ac_state_Type";
  }

  static const char* value(const ::roadbot_control::ac_state_Type_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Timestamp [s]\n"
"float64 timestamp\n"
"\n"
"# Robot Arm State Machine states\n"
"int64 reararm_sm\n"
"int64 frontarm_sm\n"
"\n"
"# Robot Arm Target Lock states\n"
"int64 target_id\n"
"float64 target_pos_X\n"
"float64 target_pos_Y\n"
"float64 target_pos_Z\n"
"float64 target_vel_X\n"
"float64 target_vel_Y\n"
"float64 target_vel_Z\n"
"float64 target_acc_X\n"
"float64 target_acc_Y\n"
"float64 target_acc_Z\n"
"\n"
"# Robot Arm Line Track states\n"
"float64 roadmarkline_pos_X\n"
"float64 roadmarkline_pos_Y\n"
"\n"
"# Place and Collect progress\n"
"int64 progress_place_count\n"
"int64 progress_place_in_total\n"
"int64 progress_collect_count\n"
"int64 progress_collect_in_total\n"
"\n"
"# Cone Storage states\n"
"int64 sb_slider_position\n"
"int64 sb_cones_in_total\n"
"int64[] sb_cones_in_stack\n"
"int64 sb_current_stack\n"
"int64 sb_current_stacklevel\n"
"\n"
"# Loading Bay States\n"
"int64 lb_left_slot\n"
"int64 lb_right_slot\n"
"\n"
"# Lanterns Rack States\n"
"int64 lr_lanterns_in_total\n"
"int64[] lr_lanterns_in_stack\n"
"int64 lr_current_stack\n"
"int64 lr_current_stacklevel\n"
"\n"
"# Rear blockage detection\n"
"bool rearDetectObjectInDeadZone\n"
"bool rearDetectObjectInPlaceZoneRight\n"
"bool rearDetectObjectInPlaceZoneCenter\n"
"bool rearDetectObjectInPlaceZoneLeft\n"
"bool rearDetectNonLockObjectInOperationZone\n"
"\n"
;
  }

  static const char* value(const ::roadbot_control::ac_state_Type_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp);
      stream.next(m.reararm_sm);
      stream.next(m.frontarm_sm);
      stream.next(m.target_id);
      stream.next(m.target_pos_X);
      stream.next(m.target_pos_Y);
      stream.next(m.target_pos_Z);
      stream.next(m.target_vel_X);
      stream.next(m.target_vel_Y);
      stream.next(m.target_vel_Z);
      stream.next(m.target_acc_X);
      stream.next(m.target_acc_Y);
      stream.next(m.target_acc_Z);
      stream.next(m.roadmarkline_pos_X);
      stream.next(m.roadmarkline_pos_Y);
      stream.next(m.progress_place_count);
      stream.next(m.progress_place_in_total);
      stream.next(m.progress_collect_count);
      stream.next(m.progress_collect_in_total);
      stream.next(m.sb_slider_position);
      stream.next(m.sb_cones_in_total);
      stream.next(m.sb_cones_in_stack);
      stream.next(m.sb_current_stack);
      stream.next(m.sb_current_stacklevel);
      stream.next(m.lb_left_slot);
      stream.next(m.lb_right_slot);
      stream.next(m.lr_lanterns_in_total);
      stream.next(m.lr_lanterns_in_stack);
      stream.next(m.lr_current_stack);
      stream.next(m.lr_current_stacklevel);
      stream.next(m.rearDetectObjectInDeadZone);
      stream.next(m.rearDetectObjectInPlaceZoneRight);
      stream.next(m.rearDetectObjectInPlaceZoneCenter);
      stream.next(m.rearDetectObjectInPlaceZoneLeft);
      stream.next(m.rearDetectNonLockObjectInOperationZone);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ac_state_Type_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::roadbot_control::ac_state_Type_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::roadbot_control::ac_state_Type_<ContainerAllocator>& v)
  {
    s << indent << "timestamp: ";
    Printer<double>::stream(s, indent + "  ", v.timestamp);
    s << indent << "reararm_sm: ";
    Printer<int64_t>::stream(s, indent + "  ", v.reararm_sm);
    s << indent << "frontarm_sm: ";
    Printer<int64_t>::stream(s, indent + "  ", v.frontarm_sm);
    s << indent << "target_id: ";
    Printer<int64_t>::stream(s, indent + "  ", v.target_id);
    s << indent << "target_pos_X: ";
    Printer<double>::stream(s, indent + "  ", v.target_pos_X);
    s << indent << "target_pos_Y: ";
    Printer<double>::stream(s, indent + "  ", v.target_pos_Y);
    s << indent << "target_pos_Z: ";
    Printer<double>::stream(s, indent + "  ", v.target_pos_Z);
    s << indent << "target_vel_X: ";
    Printer<double>::stream(s, indent + "  ", v.target_vel_X);
    s << indent << "target_vel_Y: ";
    Printer<double>::stream(s, indent + "  ", v.target_vel_Y);
    s << indent << "target_vel_Z: ";
    Printer<double>::stream(s, indent + "  ", v.target_vel_Z);
    s << indent << "target_acc_X: ";
    Printer<double>::stream(s, indent + "  ", v.target_acc_X);
    s << indent << "target_acc_Y: ";
    Printer<double>::stream(s, indent + "  ", v.target_acc_Y);
    s << indent << "target_acc_Z: ";
    Printer<double>::stream(s, indent + "  ", v.target_acc_Z);
    s << indent << "roadmarkline_pos_X: ";
    Printer<double>::stream(s, indent + "  ", v.roadmarkline_pos_X);
    s << indent << "roadmarkline_pos_Y: ";
    Printer<double>::stream(s, indent + "  ", v.roadmarkline_pos_Y);
    s << indent << "progress_place_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.progress_place_count);
    s << indent << "progress_place_in_total: ";
    Printer<int64_t>::stream(s, indent + "  ", v.progress_place_in_total);
    s << indent << "progress_collect_count: ";
    Printer<int64_t>::stream(s, indent + "  ", v.progress_collect_count);
    s << indent << "progress_collect_in_total: ";
    Printer<int64_t>::stream(s, indent + "  ", v.progress_collect_in_total);
    s << indent << "sb_slider_position: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sb_slider_position);
    s << indent << "sb_cones_in_total: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sb_cones_in_total);
    s << indent << "sb_cones_in_stack[]" << std::endl;
    for (size_t i = 0; i < v.sb_cones_in_stack.size(); ++i)
    {
      s << indent << "  sb_cones_in_stack[" << i << "]: ";
      Printer<int64_t>::stream(s, indent + "  ", v.sb_cones_in_stack[i]);
    }
    s << indent << "sb_current_stack: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sb_current_stack);
    s << indent << "sb_current_stacklevel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sb_current_stacklevel);
    s << indent << "lb_left_slot: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lb_left_slot);
    s << indent << "lb_right_slot: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lb_right_slot);
    s << indent << "lr_lanterns_in_total: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lr_lanterns_in_total);
    s << indent << "lr_lanterns_in_stack[]" << std::endl;
    for (size_t i = 0; i < v.lr_lanterns_in_stack.size(); ++i)
    {
      s << indent << "  lr_lanterns_in_stack[" << i << "]: ";
      Printer<int64_t>::stream(s, indent + "  ", v.lr_lanterns_in_stack[i]);
    }
    s << indent << "lr_current_stack: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lr_current_stack);
    s << indent << "lr_current_stacklevel: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lr_current_stacklevel);
    s << indent << "rearDetectObjectInDeadZone: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rearDetectObjectInDeadZone);
    s << indent << "rearDetectObjectInPlaceZoneRight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rearDetectObjectInPlaceZoneRight);
    s << indent << "rearDetectObjectInPlaceZoneCenter: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rearDetectObjectInPlaceZoneCenter);
    s << indent << "rearDetectObjectInPlaceZoneLeft: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rearDetectObjectInPlaceZoneLeft);
    s << indent << "rearDetectNonLockObjectInOperationZone: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rearDetectNonLockObjectInOperationZone);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROADBOT_CONTROL_MESSAGE_AC_STATE_TYPE_H
